class Buffer{static from(r,t){switch(t){case"base64":return Buffer.fromBase64(r);case"hex":return Buffer.fromHex(r)}return r}static to(r,t){switch(t){case"base64":return Buffer.toBase64(r);case"hex":return Buffer.toHex(r)}return r}static fromHex(r){let t=[];for(let e=0;e<r.length;e+=2)t.push(parseInt("0x"+r.substr(e,2),16));return new Uint8Array(t)}static fromBase64(r){let t=atob(r),e=new ArrayBuffer(t.length),a=new Uint8Array(e);for(let r=0,e=t.length;r<e;r++)a[r]=t.charCodeAt(r);return a}static toHex(r){return Array.prototype.map.call(new Uint8Array(r),r=>("00"+r.toString(16)).slice(-2)).join("")}static toBase64(r){return btoa(new Uint8Array(r))}}
class Events{constructor(){this.listeners=new Map,this.onceListeners=new Map,this.triggerdLabels=new Map}_fCheckPast(e,s){return!!this.triggerdLabels.has(e)&&(s(this.triggerdLabels.get(e)),!0)}on(e,s,t=!1){this.listeners.has(e)||this.listeners.set(e,[]),this.listeners.get(e).push(s),t&&this._fCheckPast(e,s)}onReady(e,s){this.on(e,s,!0)}once(e,s,t=!1){this.onceListeners.has(e)||this.onceListeners.set(e,[]),t&&this._fCheckPast(e,s)||this.onceListeners.get(e).push(s)}onceReady(e,s){this.once(e,s,!0)}off(e,s=!0){if(!0===s)this.removeAllListeners(e);else{let t=t=>{let i=t.get(e);i&&t.set(e,i.filter(e=>!(e===s)))};t(this.listeners),t(this.onceListeners)}}removeAllListeners(e){this.listeners.delete(e),this.onceListeners.delete(e)}emit(e,...s){let t=!1;this.triggerdLabels.set(e,...s);let i=(e,s,...i)=>{let n=e.get(s);n&&n.length&&(n.forEach(e=>{e(...i)}),t=!0)};return i(this.onceListeners,e,...s),i(this.listeners,e,...s),this.onceListeners.delete(e),t}}
class Queue extends Map{constructor(){super(),this.up=0,this.down=0,this.tid=0}updateRequest(t,e){this.tid++,this.up++,t.tid=this.tid.toString(),this.set(t.tid,e)}reset(){let t=this;t.up>50&&t.down>=t.up&&(t.up=0,t.down=0)}process(t){Array.isArray(t)?t.forEach(this.execute.bind(this)):this.execute(t)}execute(t){let e=this,s=t.tid;if(e.down++,e.has(s))try{e.get(s)(null,t)}finally{e.delete(s)}e.reset()}}
class Streams{static get isAvailable(){return"undefined"!=typeof CompressionStream}static async compress(e,r="gzip"){let t=(new TextEncoder).encode(e),s=new CompressionStream(r),a=s.writable.getWriter();return a.write(t),a.close(),new Response(s.readable).arrayBuffer()}static async decompress(e,r="gzip"){let t=new DecompressionStream(r),s=t.writable.getWriter();s.write(e),s.close();let a=await new Response(t.readable).arrayBuffer();return(new TextDecoder).decode(a)}}
class Security{constructor(){let e=this;e.VERSION=0,e.encKEY=null,e.aesKEY=null,e.exportedAES=null,e.encoder=new TextEncoder,e.decoder=new TextDecoder}getChallenge(e){return[e.challenge||"",e.keyEnc||"",e.keyVer||""].join("")}getRandom(e){let t=new Uint8Array(e);return crypto.getRandomValues(t),t}async generateAesKey(){return crypto.subtle.generateKey({name:"AES-CTR",length:128},!0,["encrypt","decrypt"])}async exportAesKey(e){let t=await crypto.subtle.exportKey("raw",e);return new Uint8Array(t)}async importRsaKey(e,t,r){let n=Buffer.from(e,"base64");return crypto.subtle.importKey("spki",n,t,!0,[r])}async verify(e,t,r){let n=Buffer.from(t,"base64"),a=this.encoder.encode(r);return crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-384"}},e,n,a)}async encryptRSA(e){let t=e;return"string"==typeof e&&(t=this.encoder.encode(e)),crypto.subtle.encrypt("RSA-OAEP",this.encKEY,t)}async encryptAesMessage(e,t,r){let n=this.encoder.encode(r),a={name:"AES-CTR",counter:t,length:128};return crypto.subtle.encrypt(a,e,n)}async decryptAesMessage(e,t,r){let n=Buffer.from(r,"hex"),a={name:"AES-CTR",counter:Buffer.from(t,"hex"),length:128};return crypto.subtle.decrypt(a,e,n)}get isValid(){return null!==this.encKEY&&null!==this.aesKEY}static get isAvailable(){return null!=crypto.subtle}async init(e){let t=this;if(!Security.isAvailable)return void console.log("Security mode not available, TLS protocol required.");console.log("Security Initializing..."),t.VERSION++,t.encKEY=await t.importRsaKey(e.keyEnc,{name:"RSA-OAEP",hash:"SHA-256"},"encrypt"),t.aesKEY=await t.generateAesKey(),t.exportedAES=await t.exportAesKey(t.aesKEY);let r=await t.importRsaKey(e.keyVer,{name:"ECDSA",namedCurve:"P-384"},"verify");if(!await t.verify(r,e.signature,t.getChallenge(e||{})))throw t.encKEY=null,t.aesKEY=null,t.exportedAES=null,new Error("Signature invalid");console.log("Security Initialized!")}async encrypt(e,t){let r=this,n=r.getRandom(16),a=new Uint8Array(n.length+r.exportedAES.length);a.set(n),a.set(r.exportedAES,n.length);let s="string"==typeof e?e:JSON.stringify(e),i=await r.encryptRSA(a),c=await r.encryptAesMessage(r.aesKEY,n,s);return!0===t?{d:c,k:i}:{d:Buffer.to(c,"hex"),k:Buffer.to(i,"hex")}}async decrypt(e){let t=e.iv,r=e.d,n=await this.decryptAesMessage(this.aesKEY,t,r),a=this.decoder.decode(n),s=JSON.parse(a);return s&&"ws"==s.type&&"data"===s.cmd&&(s=s.data),s}static async init(e){let t=new Security;return await t.init(e),t}}
class Generator extends Events{constructor(){super(),this._model={}}get api(){return this._model}stop(){this.removeAllListeners("call"),this.removeAllListeners("api"),this.detach()}detach(){let e="undefined"==typeof global?self:global;Object.keys(this._model).forEach(t=>e[t]=null),this._model={}}attach(){let e="undefined"==typeof global?self:global;Object.entries(this._model).forEach(t=>e[t[0]]=t[1])}build(e){let t=e?e.api||e:null;return t?(this._buildAPI(t),this.attach(),t):t}_buildAPI(e){let t=this;Array.isArray(e)?e.every(e=>(t._buildInstance(e),!0)):t._buildInstance(e)}_buildInstance(e){let t=this,l=null,n=null;l=t._buildNamespace(e.namespace),l[e.action]||(l[e.action]={}),n=l[e.action],e.methods.every(l=>(t._buildMethod(e.namespace,e.action,n,l),!0))}_buildNamespace(e){let t=this,l=null;return e.split(".").every(e=>(l?(l[e]||(l[e]={}),l=l[e]):(t._model[e]||(t._model[e]={}),l=t._model[e]),!0)),l}_buildMethod(e,t,l,n){let s=!1!==n.encrypt,a={n:e,c:t,m:n.name,l:n.len,e:s};l[n.name]=this._apiFn(a)}_apiFn(e){let t=this,l=e;return function(){let e,n,s=null;return e=Array.prototype.slice.call(arguments),n={namespace:l.n,action:l.c,method:l.m,e:l.e,data:e},s=new Promise((e,s)=>{t.emit("call",n,(n,a)=>{t._onResponse(n,a,l,e,s)})}),s}}_onResponse(e,t,l,n,s){e?s(e):l.c===t.action&&l.m===t.method&&t.result&&t.result.success?n(t.result):s(t.result||t)}static async build(e){let t=new Generator;return t.build(e),t}}
class WebChannel{async init(e){let t=this;t.engine&&t.stop(),t.engine=e;let a=e.Generator,n=await t.getAPI(e.apiURL);await e.registerAPI(n),e.isSockChannel||a.on("call",t.onRequest.bind(t))}stop(){let e=this.engine;this.engine=null,e.Generator.off("call"),e.isSockChannel||fetch(e.serviceURL,{method:"delete"})}async onRequest(e,t){let a=this,n=null,i=null;try{n=await a.onCall(a.engine,e)}catch(e){i=e}t(i,n)}async getAPI(e){let t=e,a=Date.now(),n=await fetch(t,{method:"get",headers:{"x-time":a}}),i=await n.json();return i.challenge=a.toString(),i}async fetchCall(e,t){let a="application/json",n={method:"post",headers:{Accept:a,"Content-Type":a},body:JSON.stringify(t)},i=await fetch(e,n);return await i.json()}async onCall(e,t){let a=e.Security,n=e.serviceURL,i=Array.isArray(t.data)&&t.data.length>0,l=t;if(a.isValid&&i&&(l=await a.encrypt(t)),l=await this.fetchCall(n,l),"err"==l.cmd)throw new Error(l.result.msg);if("enc"===l.cmd){if(!a.isValid)throw new Error("Security available on https/wss only");l=await a.decrypt(l)}return l}}
class SocketChannel{constructor(){this.queue=new Queue,this.webSocket=null,this.engine=null}async init(e){let t=this;return t.stop(),t.engine=e,new Promise((e,r)=>(t._startSocket(e,r),null))}stop(){return null!=this.webSocket&&(this.webSocket.close(),this.webSocket=null,this.engine=null,!0)}canEncrypt(e){let t=Array.isArray(e.data)&&e.data.length>0&&!1!==e.e;return this.engine.Security.isValid&&t}async onCall(e,t){let r=this,a=null,n=null,s=null,i=r.canEncrypt(e);if(r.queue.updateRequest(e,t),i&&(n=await r.engine.Security.encrypt(e.data),e.data=[n]),s={cmd:i?"enc":"data",type:"ws",data:[e]},a=JSON.stringify(s),!Streams.isAvailable)return r.webSocket.send(a);a=await Streams.compress(a),r.webSocket.send(a)}async _startSocket(e,t){let r=this,a=r.engine,n=a.Generator,s=Date.now(),i=a.serviceURL+"?q="+s;r.webSocket=new WebSocket(i,["ws4is"]),r.webSocket.binaryType="arraybuffer";let c=r.onCall.bind(r);r.webSocket.onopen=r=>{if(n.on("call",c),!a.isWSAPI)return e(!0);n.once("api",async r=>{try{r.challenge=s,await a.registerAPI(r),e(!0)}catch(e){t(e)}})},r.webSocket.onclose=e=>{n.off("call",c),r.stop()},r.webSocket.onerror=e=>{n.off("call",c),t(e),r.stop()},r.webSocket.onmessage=e=>{r._prepareMessage(e.data)}}async _prepareMessage(e){let t=this,r=null,a=t.engine.Generator;try{if(e instanceof ArrayBuffer){let t=await Streams.decompress(e);r=JSON.parse(t)}"string"==typeof e&&(r=JSON.parse(e)),r?t.onMessage(r):a.emit("error",event)}catch(e){a.emit("error",e)}}async onMessage(e){let t=null,r=this.engine,a=r.Generator,n=r.Security;if("api"===e.cmd)return a.emit("api",e.data);if("err"===e.cmd)return a.emit("error",e.result);if("enc"===e.cmd){if(!Security.isAvailable)return a.emit("error",new Error("Security available on https/wss only"));t=await n.decrypt(e)}"data"===e.cmd&&(t=e.data),t&&this.queue.process(t)}}
const ERROR_MESSAGE="Invalid definition for Engine Remote Service",ERROR_API_UNDEFIEND="API Url not defined!",ERROR_SVC_UNDEFIEND="Service Url not defined!";class Engine{constructor(e){if(!(e=e||{}).api)throw new Error(ERROR_API_UNDEFIEND);if(!e.service)throw new Error(ERROR_SVC_UNDEFIEND);let n=this;if(n.cfg=null,n.isWSAPI=!1,n.isWebChannel=!1,n.isSockChannel=!1,n.Security=null,n.Generator=null,n.WebChannel=null,n.SockChannel=null,n.cfg=e,n.isWSAPI=e.api===e.service&&0==e.api.indexOf("ws"),n.isWebChannel=0===e.service.indexOf("http"),n.isSockChannel=0===e.service.indexOf("ws"),!1===(n.isWebChannel||n.isSockChannel))throw new Error(ERROR_MESSAGE)}async init(){let e=this;e.isActive||(e.Security=new Security,e.Generator=new Generator,(e.isWebChannel||0==e.isWSAPI)&&(e.WebChannel=new WebChannel,await e.WebChannel.init(e)),e.isSockChannel&&(e.SocketChannel=new SocketChannel,await e.SocketChannel.init(e)))}async registerAPI(e){e.signature&&(this.Security.isActive||await this.Security.init(e)),this.Generator.build(e.api)}stop(){let e=this;e.WebChannel&&e.WebChannel.stop(),e.SocketChannel&&e.SocketChannel.stop(),e.Generator&&e.Generator.stop(),e.WebChannel=null,e.SocketChannel=null,e.Generator=null,e.Security=null,e.cfg=null}get api(){return this.Generator?this.Generator.api:null}get isActive(){return this.api&&this.Security}get apiURL(){return this.cfg?this.cfg.api:null}get serviceURL(){return this.cfg?this.cfg.service:null}static async init(e){let n=new Engine(e);return await n.init(),n}}